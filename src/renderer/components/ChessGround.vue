<template>
  <div class="blue merida is2d">
    <div class="grid-parent">
      <div
        ref="pockets"
        class="pockets"
      >
        <div
          :style="{visibility: variant === 'crazyhouse' ? 'visible' : 'hidden'}"
          :class="{ mirror : $store.getters.orientation == 'black'}"
        >
          <ChessPocket
            id="chesspocket_top"
            color="black"
            :pieces="piecesB"
            @selection="dropPiece"
          />
          <ChessPocket
            id="chesspocket_bottom"
            color="white"
            :pieces="piecesW"
            @selection="dropPiece"
          />
        </div>
      </div>
      <div :class="{koth: variant==='kingofthehill', rk: variant==='racingkings'}">
        <div class="cg-board-wrap">
          <div ref="board" />
          <div
            v-if="isPromotionModalVisible && !isPast"
            id="PromotionModal"
            ref="promotion"
            :style="promotionPosition"
          >
            <PromotionModal
              @close="closePromotionModal"
            />
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { mapGetters } from 'vuex'
import { Chessground } from 'chessgroundx'
import * as cgUtil from 'chessgroundx/util'
import ChessPocket from './ChessPocket'
import PromotionModal from './PromotionModal.vue'

const WHITE = true
const BLACK = false

export default {
  name: 'ChessGround',
  components: {
    ChessPocket, PromotionModal
  },
  props: {
    free: {
      type: Boolean,
      default: false
    },
    onPromotion: {
      type: Function,
      default: () => 'q'
    },
    colors: {
      type: Array,
      default: () => (['w', 'b'])
    },
    piecesW: {
      type: Array,
      default: () => ([
        { count: 0, type: 'queen' },
        { count: 0, type: 'rook' },
        { count: 0, type: 'bishop' },
        { count: 0, type: 'knight' },
        { count: 0, type: 'pawn' }
      ])
    },
    piecesB: {
      type: Array,
      default: () => ([
        { count: 0, type: 'pawn' },
        { count: 0, type: 'knight' },
        { count: 0, type: 'bishop' },
        { count: 0, type: 'rook' },
        { count: 0, type: 'queen' }
      ])
    }
  },
  data () {
    return {
      ranks: ['1', '2', '3', '4', '5', '6', '7', '8'],
      files: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'],
      selectedPiece: null,
      piecesToIdx: {
        P: 4,
        N: 3,
        B: 2,
        R: 1,
        Q: 0,
        p: 0,
        n: 1,
        b: 2,
        r: 3,
        q: 4
      },
      board: null,
      shapes: [],
      pieceShapes: [],
      promotions: [],
      promoteTo: 'q',
      isPromotionModalVisible: false,
      uciMove: undefined
    }
  },
  computed: {
    currentMove () { // returns undefined when the current fen doesnt match a move from the history, otherwise it returns move from the moves array that matches the current fen
      for (let num = 0; num < this.moves.length; num++) {
        if (this.moves[num].fen === this.fen) {
          return this.moves[num]
        }
      }
      return undefined
    },
    turn () {
      return this.$store.getters.turn ? 'white' : 'black'
    },
    legalMoves () {
      return this.$store.getters.legalMoves.split(' ')
    },
    promotionPosition () {
      if (this.uciMove) {
        const dest = this.uciMove.substring(2, 4)

        let left = (8 - cgUtil.key2pos(dest)[0]) * 12.5

        if (this.orientation === 'white') {
          left = 87.5 - left
        }

        const vertical = this.turn === this.orientation ? 0 : (7 - 3) * 12.5
        return { left: `${left}%`, top: `${vertical}%` }
      } else {
        return undefined
      }
    },
    ...mapGetters(['initialized', 'variant', 'multipv', 'hoveredpv', 'bestmove', 'redraw', 'pieceStyle', 'fen', 'lastFen', 'orientation', 'moves', 'isPast'])
  },
  watch: {
    initialized () {
      this.updateBoard()
    },
    fen () {
      this.updateBoard()
    },
    orientation () {
      this.updateBoard()
      document.dispatchEvent(new Event('renderPromotion'))
    },
    pieceStyle (pieceStyle) {
      this.updatePieceCSS(pieceStyle)
      document.dispatchEvent(new Event('renderPromotion'))
    },
    bestmove () {
      const multipv = this.multipv
      const shapes = []
      const pieceShapes = []

      if (this.$store.getters.started) {
        let lineWidth = 10
        for (let idx = 0; idx < multipv.length; ++idx) {
          if ('ucimove' in multipv[idx] && multipv[idx].ucimove.length > 0) {
            const move = multipv[idx].ucimove
            const orig = move.substring(0, 2)
            const dest = move.substring(2, 4)
            let drawShape

            if (move.indexOf('@') !== -1) {
              const pieceType = move[0].toLowerCase()
              const pieceConv = { p: 'pawn', n: 'knight', b: 'bishop', r: 'rook', q: 'queen', k: 'king' }
              pieceShapes.unshift({
                orig: dest,
                dest: dest,
                brush: 'blue',
                modifiers: { lineWidth: lineWidth },
                piece: { role: pieceConv[pieceType], color: this.turn }
              })
              drawShape = { orig: dest, brush: 'blue', modifiers: { lineWidth: lineWidth } }
            } else {
              drawShape = { orig: orig, dest: dest, brush: 'blue', modifiers: { lineWidth: lineWidth } }
            }

            // adjust color if pv line is hovered
            if (idx === this.hoveredpv) {
              drawShape.brush = 'yellow'
            }

            // put item in front of list, so that the bestmove is drawn last
            shapes.unshift(drawShape)

            lineWidth -= 2
          }
        }
      }
      this.pieceShapes = pieceShapes
      this.shapes = shapes
      this.drawShapes()
    },
    hoveredpv () {
      const index = this.shapes.length - this.hoveredpv - 1
      for (const [i, shape] of this.shapes.entries()) {
        shape.brush = i === index ? 'yellow' : 'blue'
      }
      this.drawShapes()
    },
    variant () {
      this.board.set({
        variant: this.variant,
        lastMove: false
      })
      this.updateBoard()
      this.isPromotionModalVisible = false
    }
  },
  mounted () {
    this.board = Chessground(this.$refs.board, {
      coordinates: false,
      fen: this.fen,
      turnColor: 'white',
      highlight: {
        lastMove: true, // add last-move class to squares
        check: true // add check class to squares
      },
      drawable: {
        enabled: true, // can draw
        visible: true, // can view
        eraseOnClick: false
      },
      movable: {
        events: { after: this.changeTurn(), afterNewPiece: this.afterDrag() },
        color: 'white',
        free: false,
        rookCastle: true
      },
      premovable: {
        enabled: false
      },
      orientation: this.orientation,
      resizable: true
    })
    this.resize()
    window.addEventListener('resize', this.resize)
  },
  methods: {
    resize () {
      const ev = document.createEvent('Event')
      const width = this.$el.parentNode.clientWidth - this.$refs.pockets.offsetWidth
      const height = this.$el.parentNode.clientHeight
      this.$refs.board.style.width = `${Math.min(height, width)}px`
      this.$refs.board.style.height = `${Math.min(height, width)}px`
      ev.initEvent('chessground.resize', false, false)
      document.body.dispatchEvent(ev)
    },
    showPromotionModal () {
      this.isPromotionModalVisible = true
      document.dispatchEvent(new Event('renderPromotion'))
    },
    closePromotionModal (value) {
      this.isPromotionModalVisible = false
      this.promoteTo = value
      this.uciMove = this.uciMove + String(this.promoteTo)
      this.lastMoveSan = this.$store.getters.sanMove(this.uciMove)
      this.$store.dispatch('push', this.uciMove)
      this.updateHand()
      this.afterMove()
    },
    updatePieceCSS (pieceStyle) {
      const file = document.createElement('link')
      file.rel = 'stylesheet'
      file.href = 'src/renderer/assets/images/piece-css/' + pieceStyle + '.css'
      document.head.appendChild(file)
    },
    dropPiece (event, pieceType, color) {
      this.board.dragNewPiece({ role: pieceType, color: color, promoted: false }, event)
      this.selectedPiece = pieceType
      console.log(`dropPiece: ${event} ${pieceType} ${color}`)
      console.log(`dropPiece: ${this.board.getFen()}`)
    },
    possibleMoves () {
      const dests = {}

      let fromSq
      let toSq
      for (let i = 0; i < this.legalMoves.length; i++) {
        // don't include dropping moves
        if (this.legalMoves[i].length !== 3) {
          fromSq = this.legalMoves[i].substring(0, 2)
          toSq = this.legalMoves[i].substring(2, 4)
        }
        if (fromSq in dests) {
          dests[fromSq].push(toSq)
        } else {
          dests[fromSq] = [toSq]
        }
      }
      return dests
    },
    isPromotion (uciMove) {
      try {
        this.lastMoveSan = this.$store.getters.sanMove(uciMove)
      } catch (err) {
        return true
      }
      return false
    },
    resetPockets (pieces) {
      for (let idx = 0; idx < pieces.length; idx++) {
        pieces[idx].count = 0
      }
    },
    afterDrag () {
      return (role, key) => {
        const pieces = { pawn: 'P', knight: 'N', bishop: 'B', rook: 'R', queen: 'Q' }
        const move = pieces[role] + '@' + key
        this.$store.dispatch('push', move)
        this.updateHand()
      }
    },
    changeTurn () {
      return (orig, dest) => {
        const uciMove = orig + dest
        if (this.isPromotion(uciMove)) {
          this.uciMove = uciMove
          this.showPromotionModal()
        } else {
          this.lastMoveSan = this.$store.getters.sanMove(uciMove)
          this.$store.dispatch('push', uciMove)
          this.updateHand()
          this.afterMove()
        }
      }
    },
    updatePocket (pocket, pocketPieces, color) {
      for (let idx = 0; idx < pocketPieces.length; ++idx) {
        let pieceIdx
        if (color === WHITE) {
          pieceIdx = this.piecesToIdx[pocketPieces[idx].toUpperCase()]
        } else {
          pieceIdx = this.piecesToIdx[pocketPieces[idx]]
        }
        pocket[pieceIdx].count += 1
      }
    },
    updateHand () {
      // Crazyhouse pocket pieces
      this.resetPockets(this.piecesW)
      this.resetPockets(this.piecesB)
      if (this.fen === this.lastFen) {
        this.updatePocket(this.piecesW, this.$store.getters.pocket(WHITE), WHITE)
        this.updatePocket(this.piecesB, this.$store.getters.pocket(BLACK), BLACK)
      } else {
        let i = 0
        for (let num = 0; num < this.moves.length; num++) { // i will have the index of the currently displayed move
          if (this.moves[num].fen === this.fen) {
            i = num
            break
          }
        }
        this.updatePocket(this.piecesW, this.moves[i].whitePocket, WHITE) // load the pocketpieces from the currently displayed move
        this.updatePocket(this.piecesB, this.moves[i].blackPocket, BLACK)
      }
    },
    afterMove () {
      const events = {}
      events.fen = this.fen
      events.history = [this.lastMoveSan]
      this.$emit('onMove', events)
      this.$store.dispatch('lastFen', this.fen)
    },
    updateBoard () {
      // logic to find out if a check should be displayed:
      let isCheck = false // ensures that no check is displayed when the current move was not a check
      if (this.currentMove !== undefined && (this.currentMove.name.includes('+') || this.currentMove.name.includes('#'))) { // the last move was check iff the san notation of the last move contained a '+'
        this.moves[this.moves.length - 1].check = this.turn // the check property of the board accepts a color or a boolean
        isCheck = this.currentMove.check
      }
      // logic to find out which move was last and should thus be highlighted:
      if (this.currentMove === undefined || this.moves.length === 0) {
        this.board.state.lastMove = undefined
      } else {
        const string = String(this.currentMove.uci)
        const first = string.substring(0, 2)
        const second = string.substring(2, 4)
        if (string.includes('@')) { // no longer displays a green box in the corner
          this.board.state.lastMove = [second]
        } else {
          this.board.state.lastMove = [first, second]
        }
      }
      this.board.set({
        check: isCheck,
        fen: this.fen,
        turnColor: this.turn,
        highlight: {
          lastMove: true,
          check: true
        },
        movable: this.fen === this.lastFen
          ? { // moving is only possible at the end of the line
              dests: this.possibleMoves(),
              color: this.turn
            }
          : {
              dests: {},
              color: this.turn
            },
        orientation: this.orientation
      })
      if (this.variant === 'crazyhouse') {
        this.updateHand()
      }
    },
    drawShapes () {
      if (this.board !== null) {
        this.board.setShapes([...this.shapes, ...this.pieceShapes])
      }
    }
  }
}
</script>

<style>
@import '../assets/chessground.css';
@import '../assets/theme.css';

#PromotionModal {
  position: absolute;
  z-index: 4;
  width: 12.5%;
  height: 50%;
}
.mirror {
  transform: scaleY(-1);
}
.chess-pocket {
  float: left;
  background-color: #000;
}
.grid-parent {
  display: grid;
  grid-template-columns: auto 1fr
}
.pockets {
  margin-right: 1.5px;
}
.cg-board-wrap {
  position: relative;
}
.koth cg-container::before {
  width: 25%;
  height: 25%;
  box-shadow: 0 0 10px rgba(0,0,0,0.7);
  background: rgba(230,230,230,0.2);
  content: '';
  position: absolute;
  top: 37.5%;
  left: 37.5%;
  z-index: 1;
  pointer-events: none;
  border-radius: 0px 0px 0px 0px;
}

.rk cg-container::before{
    background: rgba(230,230,230,0.2);
    width: 100%;
    height: 12.5%;
    box-shadow: 0 0 10px rgba(0,0,0,0.7);
    content: '';
    position: absolute;
    left: 0;
    z-index: 1;
    pointer-events: none;
    border-radius: 4px 4px 0px 0px;
}
</style>
